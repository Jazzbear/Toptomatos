# We wish to include all our .cpp files.
SOURCES = $(wildcard *.cpp)

# Generate a list of dependency files, by substituting the suffix of the source files and adding a prefix of the build directory.
DEPS = $(addprefix $(BUILD_DIR)/, $(SOURCES:.cpp=.d))

# Generate a list of object files to compile, by substituting the suffix of the source files and adding a prefix of the build directory.
OBJECTS = $(addprefix $(BUILD_DIR)/, $(SOURCES:.cpp=.o))

# Filename of the executable to build.
EXE = prog

# Setting the flags of the C++ compiler. We do not have any, so we leave it blank.
CXXFLAGS =

# Set a default target if none is supplied.
ifndef ARCH
ARCH = host
endif

# Making for host (Invoked with "make ARCH=host").
ifeq (${ARCH}, host)
CXX = g++
BUILD_DIR = build/host
endif

# Making for target (Invoked with "make ARCH=target").
ifeq (${ARCH}, target)
CXX = arm-devkit-g++
BUILD_DIR = build/target
endif

# Note that several targets use the "|" in the dependencies list. This is to specify an order-only dependency. We can specify the folder as an order-only dependency, in this case any changes in the timestamp will not result in a recompile of the target. See https://www.gnu.org/software/make/manual/html_node/Prerequisite-Types.html

# Target all merely depends on the executable we wish to build.
all: $(BUILD_DIR)/$(EXE)

# Using the answer from http://stackoverflow.com/a/3554442/3365039 to ensure we have the folders created.
.PHONY: $(BUILD_DIR)
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

# Target for our executable. It depends on our dependency files and object files.
$(BUILD_DIR)/$(EXE): $(DEPS) $(OBJECTS) | $(BUILD_DIR)
	$(CXX) $(CXXFLAGS) -o $@ $(OBJECTS) -lncurses

# Generate definition files for each source file.
# -MM generates makefile target, but does not include system headers.
# -MT Specifies the target name, instead of just the source filename.
# -MP generates phony targets for all the header files. This workaround errors when a header file is removed without updating the makefile (The autogenerated dependency file).
# We wish to make it point to the full path of the object file, thus we take the target ($@), and substitute the .d suffix to a .o suffix.
${BUILD_DIR}/%.d: %.cpp | $(BUILD_DIR)
	$(CXX) -MF$@ -MT$(@:.d=.o) -MM -MP $(CXXFLAGS) $<

# Target to create our object files. Since all our object files reside in the build dir, we need to specify them relative to this. The source files are still in the current directory.
# When we do the compilation, we do not need to compile all the header files the .cpp file depends on, so we only match the first dependency ($<), and save it in the build directory.
${BUILD_DIR}/%.o: %.cpp | $(BUILD_DIR)
	$(CXX) -c $< -o $@

# Include the dependency files unless we wish to build the clean target.
ifneq ($(MAKECMDGOALS), clean)
-include $(DEPS)
endif

# Remove all artifacts from the build process.
.PHONY: clean
clean:
	rm -rf build
